import os
from typing import Dict, Any, Type
from pebarest.models import BaseModel
from pebarest.testing.base_test_generator import TestGenerator


class UnitTestGenerator(TestGenerator):
    def __init__(self, app):
        super().__init__(app)

    def _validate_payload(self, model_class: Type[BaseModel], payload: Dict[str, Any]) -> list:
        warnings = []
        if not model_class or not issubclass(model_class, BaseModel):
            return warnings

        expected_fields = model_class.__annotations__.keys()
        provided_fields = payload.keys()

        missing = [field for field in expected_fields if field not in provided_fields]
        if missing:
            warnings.append(f"MISSING FIELDS: {missing}")

        extra = [field for field in provided_fields if field not in expected_fields]
        if extra:
            warnings.append(f"UNEXPECTED FIELDS: {extra}")

        return warnings

    def generate(self, test_cases: Dict[str, Dict[str, Any]] = None, output_file=None):
        """
        :param test_cases: Dicionário mapeando rotas e métodos aos dados de teste.
        :param output_file: Caminho do arquivo de saída.
        """
        if test_cases is None:
            test_cases = {}
        if output_file is None:
            output_file = "tests/test_api_generated.py"

        os.makedirs(os.path.dirname(output_file), exist_ok=True)

        lines = [
            "import unittest",
            "from app import app  # Adjust the app import according to your structure.",
            "",
            "",
            "class TestAutoGenerated(unittest.TestCase):",
            "    def setUp(self):",
            "        self.app = app",
            ""
        ]

        for path, resource_instance in self.routes.items():
            safe_path = (path
                         .replace("/", "_")
                         .replace("{", "")
                         .replace("}", "")
                         .replace("-", "_")
                         )
            if safe_path.startswith("_"): safe_path = safe_path[1:]

            for method_name in resource_instance.used_methods.keys():
                method_upper = method_name.upper()
                method_lower = method_name.lower()

                lines.append(f"    def test_{method_lower}_{safe_path}(self):")
                lines.append(f"        print('Testing: {method_upper} {path}')")

                expected_model_class = resource_instance.method_body_type.get(method_lower)

                user_payload = None
                if path in test_cases and method_upper in test_cases[path]:
                    user_payload = test_cases[path][method_upper]

                if method_upper in ['POST', 'PUT', 'PATCH']:
                    payload_var_str = "{}"

                    if user_payload:
                        payload_var_str = str(user_payload)

                    elif expected_model_class:
                        payload_var_str = "{}"

                    lines.append(f"        payload = {payload_var_str}")
                    lines.append(f"        response = self.app.test_client().{method_lower}('{path}', json=payload)")
                else:
                    lines.append(f"        response = self.app.test_client().{method_lower}('{path}')")

                lines.append("        self.assertEqual(response.status_code, 200)")
                lines.append("")

        lines.append("if __name__ == '__main__':")
        lines.append("    unittest.main()")
        lines.append("")

        with open(output_file, "w", encoding='utf-8') as f:
            f.write("\n".join(lines))
